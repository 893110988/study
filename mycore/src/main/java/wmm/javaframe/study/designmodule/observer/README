观察者模式：发布-订阅式obsrver     发布（release）--订阅（subscibe），变化（change）--更新（update）
事件驱动模型：事件驱动则更多的注重于界面与数据模型之间listener  请求（request）--响应（response），事件发生（occur）--事件处理（handle）


 二者除了业务场景的区别以外，在功能上主要有以下区别。
      1，观察者模式中观察者的响应理论上讲针对特定的被观察者是唯一的（说理论上唯一的原因是，如果你愿意，
            你完全可以在update方法里添加一系列的elseif去产生不同的响应，但LZ早就说过，你应该忘掉elseif），而事件驱动则不是，
            因为我们可以定义自己感兴趣的事情，比如刚才，我们可以监听作者发布新书，我们还可以在监听器接口中定义其它的行为。
            再比如tomcat中，我们可以监听servletcontext的init动作，也可以监听它的destroy动作。
      2，虽然事件驱动模型更加灵活，但也是付出了系统的复杂性作为代价的，因为我们要为每一个事件源定制一个监听器以及事件，
            这会增加系统的负担，各位看看tomcat中有多少个监听器和事件类就知道了。
      3，另外观察者模式要求被观察者继承Observable类，这就意味着如果被观察者原来有父类的话，就需要自己实现被观察者的功能，
            当然，这一尴尬事情，我们可以使用适配器模式弥补，但也不可避免的造成了观察者模式的局限性。事件驱动中事件源则不需要，
            因为事件源所维护的监听器列表是给自己定制的，所以无法去制作一个通用的父类去完成这个工作。
      4，被观察者传送给观察者的信息是模糊的，比如update中第二个参数，类型是Object，这需要观察者和被观察者之间有约定才可以使用这个参数。
            而在事件驱动模型中，这些信息是被封装在Event当中的，可以更清楚的告诉监听器，每个信息都是代表的什么。